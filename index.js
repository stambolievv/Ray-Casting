/**
 * @name ray-casting
 * @description Visualization of Ray Casting and Line-Line Intersection.
 *
 * @version 1.0.0
 * @author Deyan 'stambolievv' Stamboliev
 * @license Apache-2.0
 */
var t,i,e,s,n,r,h,a,o,c,l,u,d,m=Object.defineProperty,y=(t,i,e)=>(((t,i,e)=>{i in t?m(t,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[i]=e})(t,"symbol"!=typeof i?i+"":i,e),e),f=(t,i,e)=>{if(!i.has(t))throw TypeError("Cannot "+e)},g=(t,i,e)=>(f(t,i,"read from private field"),e?e.call(t):i.get(t)),p=(t,i,e)=>{if(i.has(t))throw TypeError("Cannot add the same private member more than once");i instanceof WeakSet?i.add(t):i.set(t,e)},b=(t,i,e,s)=>(f(t,i,"write to private field"),s?s.call(t,e):i.set(t,e),e),w=(t,i,e)=>(f(t,i,"access private method"),e);!function(){const t=document.createElement("link").relList;if(!(t&&t.supports&&t.supports("modulepreload"))){for(const t of document.querySelectorAll('link[rel="modulepreload"]'))i(t);new MutationObserver((t=>{for(const e of t)if("childList"===e.type)for(const t of e.addedNodes)"LINK"===t.tagName&&"modulepreload"===t.rel&&i(t)})).observe(document,{childList:!0,subtree:!0})}function i(t){if(t.ep)return;t.ep=!0;const i=function(t){const i={};return t.integrity&&(i.integrity=t.integrity),t.referrerpolicy&&(i.referrerPolicy=t.referrerpolicy),"use-credentials"===t.crossorigin?i.credentials="include":"anonymous"===t.crossorigin?i.credentials="omit":i.credentials="same-origin",i}(t);fetch(t.href,i)}}();const x=new Map;function M(t,i){const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=A(i)?s:P(i)?i(s):i;return e}function S(t,i){return function(t){var i;if(x.has(t))return x.get(t);const e=2**32,s=(1664525*(W(t)?t:"undefined"!=typeof window&&P(null==(i=window.crypto)?void 0:i.getRandomValues)&&P(window.Uint32Array)?crypto.getRandomValues(new Uint32Array(1))[0]:Math.floor(Math.random()*e))+1013904223)%e/e;return!A(t)&&x.set(t,s),s}()*(i-t)+t}function v(t,i){return Math.floor(S(t,i+1))}function V(t,i,e){const[s,n]=i,[r,h]=e;return(Math.max(s,Math.min(n,t))-s)/(n-s)*(h-r)+r}function k(t){return t*(Math.PI/180)}function W(t){return"number"==typeof t&&Number.isFinite(t)&&!Number.isNaN(t)}function A(t){return null==t||void 0===t}function P(t){return"function"==typeof t&&("[object Function]"===Object.prototype.toString.call(t)||"[object AsyncFunction]"===Object.prototype.toString.call(t))}const L=class{constructor(s=0,n=0){p(this,e),p(this,t,void 0),p(this,i,void 0),b(this,t,s),b(this,i,n),Object.freeze(this)}static get UP(){return new L(0,1)}static get LEFT(){return new L(-1,0)}static get DOWN(){return new L(0,-1)}static get RIGHT(){return new L(1,0)}set x(i){w(this,e,s).call(this,"number",i),b(this,t,i)}get x(){return g(this,t)}set y(t){w(this,e,s).call(this,"number",t),b(this,i,t)}get y(){return g(this,i)}get width(){return g(this,t)}get height(){return g(this,i)}get magnitude(){return Math.hypot(g(this,t),g(this,i))}get length(){return Math.hypot(g(this,t),g(this,i))}get direction(){return Math.atan2(g(this,i),g(this,t))}get angle(){return Math.atan2(g(this,i),g(this,t))}get absoluteX(){return Math.abs(g(this,t))}get absoluteY(){return Math.abs(g(this,i))}set(n,r=n){return w(this,e,s).call(this,"number",n),w(this,e,s).call(this,"number?",r),b(this,t,n),b(this,i,r),this}add(n){return w(this,e,s).call(this,"Vector",n),new L(g(this,t)+n.x,g(this,i)+n.y)}addSelf(n){return w(this,e,s).call(this,"Vector",n),b(this,t,g(this,t)+n.x),b(this,i,g(this,i)+n.y),this}subtract(n){return w(this,e,s).call(this,"Vector",n),new L(g(this,t)-n.x,g(this,i)-n.y)}subtractSelf(n){return w(this,e,s).call(this,"Vector",n),b(this,t,g(this,t)-n.x),b(this,i,g(this,i)-n.y),this}multiply(n){return w(this,e,s).call(this,"Vector",n),new L(g(this,t)*n.x,g(this,i)*n.y)}multiplySelf(n){return w(this,e,s).call(this,"Vector",n),b(this,t,g(this,t)*n.x),b(this,i,g(this,i)*n.y),this}divide(n){return w(this,e,s).call(this,"Vector",n),new L(g(this,t)/n.x,g(this,i)/n.y)}divideSelf(n){return w(this,e,s).call(this,"Vector",n),b(this,t,g(this,t)/n.x),b(this,i,g(this,i)/n.y),this}clamp(n,r){w(this,e,s).call(this,"Vector",n),w(this,e,s).call(this,"Vector",r);const h=Math.max(Math.min(g(this,t),r.x),n.x),a=Math.max(Math.min(g(this,i),r.y),n.y);return new L(h,a)}clampSelf(n,r){w(this,e,s).call(this,"Vector",n),w(this,e,s).call(this,"Vector",r);const h=Math.max(Math.min(g(this,t),r.x),n.x),a=Math.max(Math.min(g(this,i),r.y),n.y);return b(this,t,h),b(this,i,a),this}addScalar(n,r=n){return w(this,e,s).call(this,"number",n),w(this,e,s).call(this,"number?",r),new L(g(this,t)+n,g(this,i)+r)}addScalarSelf(n,r=n){return w(this,e,s).call(this,"number",n),w(this,e,s).call(this,"number?",r),b(this,t,g(this,t)+n),b(this,i,g(this,i)+r),this}subtractScalar(n,r=n){return w(this,e,s).call(this,"number",n),w(this,e,s).call(this,"number?",r),new L(g(this,t)-n,g(this,i)-r)}subtractScalarSelf(n,r=n){return w(this,e,s).call(this,"number",n),w(this,e,s).call(this,"number?",r),b(this,t,g(this,t)-n),b(this,i,g(this,i)-r),this}multiplyScalar(n,r=n){return w(this,e,s).call(this,"number",n),w(this,e,s).call(this,"number?",r),new L(g(this,t)*n,g(this,i)*r)}multiplyScalarSelf(n,r=n){return w(this,e,s).call(this,"number",n),w(this,e,s).call(this,"number?",r),b(this,t,g(this,t)*n),b(this,i,g(this,i)*r),this}divideScalar(n,r=n){return w(this,e,s).call(this,"number",n),w(this,e,s).call(this,"number?",r),new L(g(this,t)/n,g(this,i)/r)}divideScalarSelf(n,r=n){return w(this,e,s).call(this,"number",n),w(this,e,s).call(this,"number?",r),b(this,t,g(this,t)/n),b(this,i,g(this,i)/r),this}clampScalar(n,r){w(this,e,s).call(this,"number",n),w(this,e,s).call(this,"number",r);const h=Math.max(Math.min(g(this,t),r),n),a=Math.max(Math.min(g(this,i),r),n);return new L(h,a)}clampScalarSelf(n,r){w(this,e,s).call(this,"number",n),w(this,e,s).call(this,"number",r);const h=Math.max(Math.min(g(this,t),r),n),a=Math.max(Math.min(g(this,i),r),n);return b(this,t,h),b(this,i,a),this}dotProduct(n){return w(this,e,s).call(this,"Vector",n),g(this,t)*n.x+g(this,i)*n.y}crossProduct(n){return w(this,e,s).call(this,"Vector",n),g(this,t)*n.y-g(this,i)*n.x}distance(n){return w(this,e,s).call(this,"Vector",n),Math.hypot(g(this,t)-n.x,g(this,i)-n.y)}lerp(n,r){return w(this,e,s).call(this,"Vector",n),w(this,e,s).call(this,"number",r),b(this,t,g(this,t)+(n.x-g(this,t))*r),b(this,i,g(this,i)+(n.y-g(this,i))*r),this}rotate(n,r){w(this,e,s).call(this,"Vector",n),w(this,e,s).call(this,"number",r);const h=k(r),a=Math.cos(h),o=Math.sin(h),c=g(this,t)-n.x,l=g(this,i)-n.y,u=c*a-l*o+n.x,d=c*o+l*a+n.y;return new L(u.toString().includes("e-")?0:u,d.toString().includes("e-")?0:d)}rotateSelf(n,r){w(this,e,s).call(this,"Vector",n),w(this,e,s).call(this,"number",r);const h=k(r),a=Math.cos(h),o=Math.sin(h),c=g(this,t)-n.x,l=g(this,i)-n.y,u=c*a-l*o+n.x,d=c*o+l*a+n.y;return b(this,t,u.toString().includes("e-")?0:u),b(this,i,d.toString().includes("e-")?0:d),this}invert(){return new L(-1*g(this,t),-1*g(this,i))}invertSelf(){return b(this,t,-1*g(this,t)),b(this,i,-1*g(this,i)),this}normalize(){const e=Math.hypot(g(this,t),g(this,i));return 0===e?new L:new L(g(this,t)/e,g(this,i)/e)}normalizeSelf(){const e=Math.hypot(g(this,t),g(this,i));return 0===e||(b(this,t,g(this,t)/e),b(this,i,g(this,i)/e)),this}toFixed(n){w(this,e,s).call(this,"number",n);const r=10**n;return b(this,t,Math.trunc(g(this,t)*r)/r),b(this,i,Math.trunc(g(this,i)*r)/r),this}ceil(n=0){w(this,e,s).call(this,"number?",n);const r=10**n;return b(this,t,Math.ceil(g(this,t)*r)/r),b(this,i,Math.ceil(g(this,i)*r)/r),this}floor(n=0){w(this,e,s).call(this,"number?",n);const r=10**n;return b(this,t,Math.floor(g(this,t)*r)/r),b(this,i,Math.floor(g(this,i)*r)/r),this}round(n=0){w(this,e,s).call(this,"number?",n);const r=10**n;return b(this,t,Math.round(g(this,t)*r)/r),b(this,i,Math.round(g(this,i)*r)/r),this}min(n){return w(this,e,s).call(this,"Vector",n),g(this,t)>n.x&&b(this,t,n.x),g(this,i)>n.y&&b(this,i,n.y),this}max(n){return w(this,e,s).call(this,"Vector",n),g(this,t)<n.x&&b(this,t,n.x),g(this,i)<n.y&&b(this,i,n.y),this}equals(n){return w(this,e,s).call(this,"Vector",n),g(this,t)===n.x&&g(this,i)===n.y}clear(){return b(this,t,0),b(this,i,0),this}copy(n){return w(this,e,s).call(this,"Vector",n),b(this,t,n.x),b(this,i,n.y),this}clone(){return new L(g(this,t),g(this,i))}toString(){return`x: ${g(this,t)}, y: ${g(this,i)}`}toArray(){return[g(this,t),g(this,i)]}toObject(){return{x:g(this,t),y:g(this,i)}}toSize(){return{width:g(this,t),height:g(this,i)}}};let j=L;t=new WeakMap,i=new WeakMap,e=new WeakSet,s=function(t,i){let e=!1;switch(t){case"Vector":i instanceof L||(e=!0);break;case"number":W(i)||(e=!0);break;case"number?":A(i)||W(i)||(e=!0)}if(e)throw new TypeError(`[Vector2D] Expected a ${t.endsWith("?")?t.slice(0,-1):t}, but received ${typeof i}`)};class E{constructor({name:t="Line",position:i={x:0,y:0},angle:e=0,config:s={}}={}){y(this,"name"),p(this,n,void 0),p(this,r,void 0),p(this,h,void 0),p(this,a,void 0),p(this,o,void 0),this.name=t,b(this,n,s),b(this,r,new j),b(this,h,new j),b(this,a,e),this.update(new j(i.x,i.y))}get start(){return g(this,r)}get end(){return g(this,h)}set intersectionPoint(t){b(this,o,t)}get intersectionPoint(){return g(this,o)}draw(t){var i;const{gradient:e,color:s,lineWidth:r}=g(this,n),h=t.createLinearGradient(this.start.x,this.start.y,this.end.x,this.end.y);e&&Object.entries(e).forEach((([t,i])=>h.addColorStop(Number(t),i)));const a=null!=(i=this.intersectionPoint)?i:this.end;t.beginPath(),t.moveTo(this.start.x,this.start.y),t.lineTo(a.x,a.y),t.closePath(),t.lineWidth=r,t.strokeStyle=e?h:s,t.stroke()}update(t){const{length:i}=g(this,n);g(this,r).copy(t),b(this,h,g(this,r).addScalar(0,i).rotateSelf(g(this,r),g(this,a)))}intersection(t){const i=t.start.subtract(this.start),e=this.end.subtract(this.start),s=t.end.subtract(t.start),n=i.crossProduct(e),r=e.crossProduct(s);if(0===n&&0===r){if(this.start.equals(t.start)||this.end.equals(t.start)||this.start.equals(t.end)||this.end.equals(t.end))return{type:"colinear-overlapping"};return[i.toArray(),t.start.subtract(this.end).toArray(),t.end.subtract(this.start).toArray(),t.end.subtract(this.end).toArray()].flat().every((t=>t<0))?{type:"colinear-joint"}:{type:"colinear-disjoint"}}if(0===r)return{type:"parallel-non-intersecting"};const h=n/r,a=i.crossProduct(s)/r;if(a>=0&&a<=1&&h>=0&&h<=1){return{type:"intersection",point:this.start.add(e.multiplyScalar(a))}}return{type:"no-intersection"}}}n=new WeakMap,r=new WeakMap,h=new WeakMap,a=new WeakMap,o=new WeakMap;c=new WeakMap,l=new WeakMap,u=new WeakSet,d=function(){const{amount:t=0,angle:i,singleLine:e}=g(this,c);return M(t,(s=>new E({name:`Ray${s}`,angle:V(s,[0,t],i),config:e})))};const N={scene:{backgroundColor:"#111"},rays:{amount:500,angle:[0,360],singleLine:{length:400,lineWidth:1,gradient:{0:"lightgray",.1:"darkgray",1:"transparent"}}},lines:{amount:{min:10,max:15},angle:{min:0,max:360},length:{min:100,max:500},singleLine:{lineWidth:3,color:"blue"}}},O=document.getElementById("canvas");O.width=window.innerWidth,O.height=window.innerHeight;const q=O.getContext("2d");if(!q)throw new Error("Failed to get 2D context");const C=new j,F=new class{constructor({name:t="Rays",config:i={}}={}){p(this,u),y(this,"name"),p(this,c,void 0),p(this,l,void 0),this.name=t,b(this,c,i),b(this,l,w(this,u,d).call(this))}draw(t){for(const i of g(this,l))i.draw(t)}update(t){for(const i of g(this,l))i.update(t)}intersect(t){const i=(e=t,(Array.isArray?Array.isArray(e):e instanceof Array)?t:[t]);var e;for(const s of g(this,l)){let t=null,e=1/0;for(const n of i){const i=s.intersection(n);if(i.point){const n=s.start.distance(i.point);n<e&&(e=n,t=i.point)}s.intersectionPoint=t||s.end.clone()}}}}({config:N.rays}),R=function(t){const{amount:i,angle:e,length:s,singleLine:n}=t;return M(v(i.min,i.max),(()=>{const t={position:{x:v(0,O.width),y:v(0,O.height)},angle:v(e.min,e.max),config:{length:v(s.min,s.max),...n}};return new E(t)}))}(N.lines);!function t(){q.fillStyle=N.scene.backgroundColor,q.fillRect(0,0,O.width,O.height),F.draw(q),F.update(C);for(const i of R)i.draw(q);F.intersect(R),requestAnimationFrame(t)}(),window.addEventListener("pointermove",(({clientX:t,clientY:i})=>{const{top:e,right:s,bottom:n,left:r}=O.getBoundingClientRect();C.set((t-r)/Math.max(s-r,1)*O.width,(i-e)/Math.max(n-e,2)*O.height)}));
